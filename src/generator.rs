use std::io::Write;

use super::Error;
use cmake_codegen::simple_flags_to_rust_writer;
use cmake_config::SimpleFlag;
use config::Arch;

const ARMV7_ASM: &str = include_str!("asm/arm.s");
const AARCH64_ASM: &str = include_str!("asm/aarch64.s");
const X86_ASM: &str = include_str!("asm/x86.s");
const X86_64_ASM: &str = include_str!("asm/x86_64.s");

pub struct Generator<'a, 'b, 'c, W: Write + 'a> {
    writer: &'a mut W,
    package_module_name: &'b str,
    arch: &'b Arch,
    flags: &'c [SimpleFlag],
}

impl<'a, 'b, 'c, W: Write> Generator<'a, 'b, 'c, W> {
    pub fn new(
        writer: &'a mut W,
        package_module_name: &'b str,
        arch: &'b Arch,
        flags: &'c [SimpleFlag],
    ) -> Self
    where
        W: Write,
    {
        Self {
            writer,
            package_module_name,
            arch,
            flags,
        }
    }

    pub fn generate(&mut self) -> Result<(), Error> {
        self.generate_features_and_crates()?;
        writeln!(self.writer, "extern crate {};", self.package_module_name)?;

        self.writer.write_all(
            br###"
use core::mem;
use sel4_sys::*;

#[cfg(feature = "alloc")]
#[global_allocator]
static ALLOCATOR: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// include the seL4 kernel configurations
#[allow(dead_code)]
#[allow(non_upper_case_globals)]
pub mod sel4_config {"###,
        )?;
        simple_flags_to_rust_writer(self.flags, self.writer, 4)?;
        self.writer.write_all(b"}\n\n")?;

        self.writer
            .write_all(BOOT_INFO_AND_LANG_ITEM_CODE.as_bytes())?;

        self.writer.write_all(
            br####"
#[cfg(feature = "KernelDebugBuild")]
#[inline(always)]
pub fn debug_halt() {
    unsafe { sel4_sys::seL4_DebugHalt() };
}

fn get_untyped(info: &seL4_BootInfo, size_bytes: usize) -> Option<seL4_CPtr> {
    let mut idx = 0;
    for i in info.untyped.start..info.untyped.end {
        if (1 << info.untypedList[idx].sizeBits) >= size_bytes {
            return Some(i);
        }
        idx += 1;
    }
    None
}

const CHILD_STACK_SIZE: usize = 4096;
static mut CHILD_STACK: *const [u64; CHILD_STACK_SIZE] =
    &[0; CHILD_STACK_SIZE];

        "####,
        )?;
        self.generate_call_child()?;
        self.generate_main()?;
        let asm = match *self.arch {
            Arch::X86 => X86_ASM,
            Arch::X86_64 => X86_64_ASM,
            Arch::Armv7 => ARMV7_ASM,
            Arch::Aarch64 => AARCH64_ASM,
        };
        writeln!(self.writer, "\nglobal_asm!(r###\"{}\"###);\n", asm)?;
        Ok(())
    }

    fn generate_features_and_crates(&mut self) -> Result<(), Error> {
        self.writer.write_all(
            br###"// NOTE: this file is generated by fel4
// NOTE: Don't edit it here; your changes will be lost at the next build!
#![no_std]
#![cfg_attr(feature = "alloc", feature(alloc))]
#![feature(lang_items, core_intrinsics)]
#![feature(global_asm)]
#![cfg_attr(feature = "alloc", feature(global_allocator))]

extern crate sel4_sys;
#[cfg(feature = "alloc")]
extern crate wee_alloc;
#[cfg(feature = "alloc")]
extern crate alloc;

#[cfg(all(feature = "test", feature = "alloc"))]
#[macro_use]
extern crate proptest;
"###,
        )?;
        Ok(())
    }

    fn generate_call_child(&mut self) -> Result<(), Error> {
        self.writer.write_all(
            br###"
#[cfg(feature = "test")]
fn call_child() {"###,
        )?;
        self.writer.write_fmt(format_args!(
            "\n    {}::fel4_test::run();\n",
            self.package_module_name
        ))?;
        self.writer.write_all(b"    }\n")?;
        self.writer.write_all(
            br###"
#[cfg(not(feature = "test"))]
fn call_child() {"###,
        )?;
        self.writer
            .write_fmt(format_args!("\n    {}::run();\n", self.package_module_name))?;
        self.writer.write_all(b"}\n")?;
        Ok(())
    }

    fn generate_main(&mut self) -> Result<(), Error> {
        self.writer.write_all(
            br###"
fn main() {
    let bootinfo = unsafe { &*BOOTINFO };
    let cspace_cap = seL4_CapInitThreadCNode;
    let pd_cap = seL4_CapInitThreadVSpace;
    let tcb_cap = bootinfo.empty.start;
    let untyped = get_untyped(bootinfo, 1 << seL4_TCBBits).unwrap();
    let retype_err: seL4_Error = unsafe {
        seL4_Untyped_Retype(
            untyped,
            api_object_seL4_TCBObject.into(),
            seL4_TCBBits.into(),
            cspace_cap.into(),
            cspace_cap.into(),
            seL4_WordBits.into(),
            tcb_cap,
            1,
        )
    };
    if retype_err != 0 {
        debug_halt();
    }
    let tcb_err: seL4_Error = unsafe {
        seL4_TCB_Configure(
            tcb_cap,
            seL4_CapNull.into(),
            cspace_cap.into(),
            seL4_NilData.into(),
            pd_cap.into(),
            seL4_NilData.into(),
            0,
            0,
        )
    };
    if tcb_err != 0 {
        debug_halt();
    }
    let stack_base = unsafe { CHILD_STACK as usize };
    let stack_top = stack_base + CHILD_STACK_SIZE;
    let mut regs: seL4_UserContext = unsafe { mem::zeroed() };
"###,
        )?;

        let (call_field, stack_field) = match *self.arch {
            Arch::X86 | Arch::X86_64 => ("rip", "rsp"),
            Arch::Armv7 => ("pc", "sp"),
            Arch::Aarch64 => ("pc", "sp"),
        };
        writeln!(
            self.writer,
            "    regs.{} = call_child as seL4_Word;\n    regs.{} = stack_top as seL4_Word;",
            call_field, stack_field
        )?;
        self.writer.write_all(
            b"
    let _: u32 =
        unsafe { seL4_TCB_WriteRegisters(tcb_cap, 0, 0, 2, &mut regs) };
    let _: u32 = unsafe {
        seL4_TCB_SetPriority(tcb_cap, seL4_CapInitThreadTCB.into(), 255)
    };
    let _: u32 = unsafe { seL4_TCB_Resume(tcb_cap) };
    loop {
        unsafe {
            seL4_Yield();
        }
    }
}
        ",
        )?;
        Ok(())
    }
}

const BOOT_INFO_AND_LANG_ITEM_CODE: &str = r##"
pub static mut BOOTINFO: *mut seL4_BootInfo = (0 as *mut seL4_BootInfo);
static mut RUN_ONCE: bool = false;

#[no_mangle]
pub unsafe extern "C" fn __sel4_start_init_boot_info(
    bootinfo: *mut seL4_BootInfo,
) {
    if !RUN_ONCE {
        BOOTINFO = bootinfo;
        RUN_ONCE = true;
        seL4_SetUserData((*bootinfo).ipcBuffer as usize as seL4_Word);
    }
}

#[lang = "termination"]
trait Termination {
    fn report(self) -> i32;
}

impl Termination for () {
    fn report(self) -> i32 {
        0
    }
}

#[lang = "start"]
#[no_mangle]
fn lang_start<T: Termination + 'static>(
    main: fn() -> T,
    _argc: isize,
    _argv: *const *const u8,
) -> isize {
    main();
    panic!("Root task should never return from main!");
}

#[lang = "panic_fmt"]
#[no_mangle]
pub extern "C" fn panic_fmt(
    fmt: core::fmt::Arguments,
    file: &'static str,
    line: u32,
) -> ! {
    #[cfg(feature = "KernelPrinting")]
    {
        use core::fmt::Write;
        let _ = write!(
            sel4_sys::DebugOutHandle,
            "panic at {}:{}: ",
            file,
            line
        );
        let _ = sel4_sys::DebugOutHandle.write_fmt(fmt);
        let _ = sel4_sys::DebugOutHandle.write_char('\n');
        let _ = write!(
            sel4_sys::DebugOutHandle,
            "----- aborting from panic -----\n"
        );
    }
    unsafe {
        core::intrinsics::abort()
    }
}

#[lang = "eh_personality"]
#[no_mangle]
pub fn eh_personality() {
    #[cfg(feature = "KernelPrinting")]
    {
        use core::fmt::Write;
        let _ = write!(
            sel4_sys::DebugOutHandle,
            "----- aborting from eh_personality -----\n"
        );
    }
    unsafe {
        core::intrinsics::abort();
    }
}

#[lang = "oom"]
#[no_mangle]
pub extern "C" fn oom() -> ! {
    #[cfg(feature = "KernelPrinting")]
    {
        use core::fmt::Write;
        let _ = write!(
            sel4_sys::DebugOutHandle,
            "----- aborting from out-of-memory -----\n"
        );
    }
    unsafe {
        core::intrinsics::abort()
    }
}
"##;
